## timer

在机器模式下处理定时器中断，由于机器模式中不使用satp控制内存地址翻译，应该是和监督者模式的内存权限管理是分开的，目前了解和PMP寄存器有关。

当前的在机器模式下的定时器中断，也使用sd和ld指令访问了内存，暂不知道如何控制内存地址翻译，定时器中断里只有很少的代码然后引发了一个软件中断后返回，软件中断由监督者模式处理。

另外代码中系统运行后，从不关闭机器模式中断，所以任何时候都可以触发定时器中断，理论上定时器中断需要保存除了Caller寄存器，但是由于定时器中断中只使用了a0,a1,a2且不会跳转到任何c代码（c代码中使用什么寄存器由编译器控制（虽然也也可以间接由选项控制）），所有只保存了a0,a1,a2。其他未使用的寄存器不会被破坏，所以未保存也不影响。

## 参考
https://github.com/FrankZn/xv6-riscv-book-Chinese/blob/main/Chapter-5.md

### 5.4 Timer interrupts

Xv6使用定时器中断来维护它的时钟，并使它能够切换计算密集型进程；usertrap和kerneltrap中的yield调用会导致这种切换。每个RISC-V CPU的时钟硬件都会抛出时钟中断。Xv6对这个时钟硬件进行编程，使其定期周期性地中断相应的CPU。

RISC-V要求在机器模式下处理定时器中断，而不是监督者模式。RISCV机器模式执行时没有分页，并且有一套单独的控制寄存器，因此在机器模式下运行普通的xv6内核代码是不实用的。因此，xv6对定时器中断的处理与上面谈到的trap机制完全分离了。

在main执行之前的start.c，是在机器模式下执行的。它设置了接收定时器中断(kernel/start.c:57)。一部分工作是对CLINT硬件（core-local interruptor）进行编程，使其每隔一定时间产生一次中断。另一部分是设置一个类似于trapframe的暂存区，帮助定时器中断处理程序保存寄存器和CLINT寄存器的地址。最后，start将mtvec设置为timervec，启用定时器中断。

定时器中断可能发生在用户或内核代码执行的任何时候；内核没有办法在关键操作中禁用定时器中断。因此，定时器中断处理程序必须以保证不干扰被中断的内核代码的方式进行工作。基本策略是处理程序要求RISC-V引发一个软件中断并立即返回。RISC-V用普通的trap机制将软件中断传递给内核，并允许内核禁用它们。处理定时器中断产生的软件中断的代码可以在devintr（kernel/trap.c:204）中看到。

机器模式的定时器中断向量是timervec(kernel/kernelvec.S:93)。它在start准备的暂存区保存一些寄存器，告诉CLINT何时产生下一个定时器中断，使RISC-V产生一个软件中断，恢复寄存器，然后返回。在定时器中断处理程序中没有C代码。